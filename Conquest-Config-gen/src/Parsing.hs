{-# LANGUAGE TupleSections #-}
{-# LANGUAGE OverloadedStrings #-}
module Parsing where
import Data.Map ((!), Map)
import qualified Data.Map as Map
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.IO as TI
import Text.Parsec
import qualified Text.Parsec.Token as Tok
import Text.Parsec.Token hiding (lexeme)
import Text.Parsec.Combinator
import System.Directory
import System.Environment
import Control.Monad.State
import Data.Maybe
import Control.Applicative ((<$>), (<*>))
import qualified Control.Applicative as A
import Data.Char (chr, ord)

lexeme :: Parsec Text a ()
lexeme = many (oneOf " \t") >> return () -- shush.

multiline :: Parsec Text a ()
multiline = many1 (lexeme >> (crlf <|> newline)) >> lexeme

parseConfigFile :: String -> IO (Either Text (Either ParseError Config))
parseConfigFile f = do
  s <- TI.readFile f
  parseConfigString s f

parseConfigString :: Text -> String -> IO (Either Text (Either ParseError Config))
parseConfigString s f = do
  (b, r) <- expandIncludes s f
  if b
    then return $ Left r
    else return $ Right $ runParser configParser (0,0) f r

expandIncludes :: Text -> String -> IO (Bool, Text)
expandIncludes s f = let
  a = T.lines s
  b = any ((== '#') . T.head) a
  x =
    map (\t -> if (T.head t == '#')
          then do {ff <- TI.readFile $ T.unpack $ T.tail t; fmap snd $ expandIncludes ff (T.unpack $ T.tail t)}
          else return t)
    a
  in fmap (b,) $ foldr (\i a -> do {y <- i; z <- a; return $ y `T.append` z}) (return "") x

configParser :: Parsec Text (Int,Int) Config
configParser = do
  xs <- many1 (commentStep <|> wrap '(' ')' nodeStep <|> wrap '{' '}' pieceStep)
  return $ foldr applyStep (Cfg Map.empty []) xs
  where
    wrap :: Char -> Char -> Parsec Text a b -> Parsec Text a b
    wrap a b c = do
      char a
      x <- c
      char b
      return x
    commentStep :: Parsec Text (Int, Int) Config
    commentStep = do
      char ';'
      manyTill anyChar $ char '\n'
      return $ Cfg Map.empty []
    parseInt :: Parsec Text (Int,Int) Int
    parseInt = fmap read $ many1 digit
    nodeStep :: Parsec Text (Int,Int) Config
    nodeStep = do
      multiline
      piece <- parseInt
      multiline
      nodet <- anyChar
      v <- many1 $ do {n <- parseInt; multiline; return n}
      (num,bl) <- getState
      putState (num + 1, bl)
      return (Cfg (Map.singleton num (piece, nodet, v)) [])

    pieceStep :: Parsec Text (Int,Int) Config
    pieceStep = do
      nam <- manyTill anyChar multiline
      maxy <- parseInt
      multiline
      maxc <- parseInt
      multiline

      ls <- many1 parseAction
      
      (bl, num) <- getState
      putState (bl, num + 1)
      let p =  PT {maxMoves = maxy, maxCarry = maxc, actions = Map.fromList ls, name = T.pack nam}
      return (Cfg Map.empty [p])

    parseAction :: Parsec Text (Int, Int) (Char, (Bool, Action))
    parseAction = do
      ty <- letter
      try (do {char ty; y <- rest ty; return (ty, (True, y))}) <|> do {y <- rest ty; return (ty, (False, y))}
        where
          rest :: Char -> Parsec Text (Int, Int) Action
          rest c = do
            ls <- many1 $ do {n <- parseInt; multiline; return n}
            if c `elem` ("kCmd" :: String)
              then return $ PA ls
              else if c `elem` ("cr" :: String)
                   then return $ IPA $ splitter ls
                   else return $ NA $ map chr ls
          splitter [] = []
          splitter [a] = []
          splitter (a:b:c) = (a,b) : (splitter c)
            
applyStep :: Config -> Config -> Config
applyStep (Cfg m o) (Cfg l p) = Cfg (Map.union m l) (o ++ p)


data Node a = Node a [Node a]
data Action = PA [Int] | IPA [(Int, Int)] | NA [Char]
data PT = PT {maxMoves :: Int, maxCarry :: Int, actions :: Map Char (Bool, Action), name::Text}
data Config = Cfg (Map.Map Int (Int, Char, [Int])) [PT]

serializeConfig :: Config -> Text
serializeConfig c@(Cfg mv ts) =
  ";; File autogenerated with the Conquest Config tool. See <https://github.com/pickten/Conquest/Conquest-Config-gen> for details."
  `T.append`
  (foldr T.append "" $ map serializeType ts)
  `T.append`
  serializeMap c mv

serializeType :: PT -> Text
serializeType x =
  "{" `T.append`
  name x `T.append` "\n" `T.append`
  T.pack (show $ maxMoves x) `T.append` "\n" `T.append`
  T.pack (show $ maxCarry x) `T.append` "\n" `T.append`
  foldr (\i a -> a `T.append` "\n" `T.append` serializeAction i (actions x)) "" (Map.keys $ actions x) `T.append`
  "}"


serializeAction :: Char -> Map Char (Bool, Action) -> Text
serializeAction c m =
  let
    b :: Bool
    a :: Action
    (b,a) = m ! c
    chars :: Text
    chars = T.pack $ if b then [c,c] else [c]
    aa :: Text
    aa = case a of
      PA x -> foldr (\i a -> a `T.append` "\n" `T.append` T.pack (show i)) "" x
      IPA x -> foldr (\i a -> a `T.append` "\n" `T.append` T.pack (show $ fst i)
                       `T.append` "\n" `T.append` T.pack (show $ snd i)) "" x
      NA x -> foldr (\i a -> a `T.append` "\n" `T.append` T.pack (show $ ord i)) "" x
  in chars `T.append` "\n" `T.append` aa

serializeMap :: Config -> Map Int (Int, Char, [Int]) -> Text
serializeMap c m = foldr (\i a -> a `T.append` "\n" `T.append` serializeNode i m c) "" $ Map.keys m

serializeNode :: Int -> Map Int (Int, Char, [Int]) -> Config  -> Text
serializeNode i m (Cfg _ c)= let
  (x, r, is) = m ! i
  in "(\n" `T.append` T.pack (show x) `T.append` "\n"
  `T.append` "; piece type: " `T.append` name (c !! x) `T.append` "\n"
  `T.append` T.pack [r] `T.append` "\n"
  `T.append` foldr (\l a -> a `T.append` "\n" `T.append` T.pack (show l)) "" is
  `T.append` "\n)"
